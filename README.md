## Key-Value Storage

 Мой курсовой проект по C++. 2017г, СПбАУ РАН.

### Что это?

В общих чертах, проект представлет собой динамическую библиотеку, предоставляющуюgit
доступ к классу **KeyValueStorage<Key, Value, Comparator = std::less<Key>>**, который позволяет
хранить объекты типа **Value** с доступом по ключу типа **Key** и поддерживает следующие запросы:
 * set(Key, Value) - установить значение Value по ключу Key (если такой ключ уже был, заменить Value)
 * del(Key) - удалить из хранилища ключ Key и соотвествующее ему значение
 * get(Key) - получить значение, хранящееся по ключу Key
 * getRange(LeftKey, RightKey) - выдаёт пары ключи-значения на полуинтервале [LeftKey, RightKey)
 * KeyValueStorage("tree name", true) - загрузить хранилище, оставшееся после оборвавшейся сессии. 
 При этом не гарантируется, что последняя проделанная над хранилищем операция сохранена. Скорее всего,
 все изменения, сделанные во время последней операции, будут отменены до состояния, предшествующего ей.
 Но при этом гарантируется, что полученная структура будет в одном из двух состояний и будет соотвествовать 
 корректной структуре либо сразу до последней операции, либо после неё.
 
 Каждая структура в конструкторе требует предоставить строку - имя структуры. В случае падения программы при повторной 
 её загрузке можно будет указать в конструкторе имя структуры, которую требуется восстановить, и по нему получить
 структуру в оставленном состоянии (типы ключа и значения при этом также должны совпадать с теми, что были до падения).
 
 В случае корректного завершения программы, хранилище очищается, попытки восстановления приведут к соответствующей 
ошибке.
 
### Как это устроено?

В основе реализации лежит B+ дерево. Каждый раз, когда к нему поступает запрос,
 спуском по дереву определяется место искомого ключа. После чего если это был запрос на получение значения, 
 соотвествующее значение запрашивается из файла, хранящего их. Аналогично с заменой или удалением 
 ключей/значений из файлов работают операции set и del.
 
Важно понимать, что все вершины дерева хранятся в бинарном виде на диске, а не в оперативной памяти, 
 всвязи с чем константа времени работы может быть выше ожидаемой.

Структура также поддерживает журналирование, за счёт чего может откатываться до последнего инвариантного состояния 
в случае падения программы.

### Асимптотика
 Поскольку в основе реализации лежит B-дерево с константным размером вершины 256, то 
 ответ на запрос будет работать за $O(\log_{256} n)$ на запрос, где $n$ - число добавленных в дерево ключей.  
    
### Руководство к запуску

    git clone https://github.com/annikura/key-value-storage.git
    cd key-value-storage
    cmake CMakeLists.txt
 Далее в зависимости от целей можно воспользоваться командами 
    
    make test_all && ./test_all
чтобы запустить тесты или

    make main && ./main
чтобы запустить тестовое приложение.

Если же необходимо воспользоваться библиотекой, следует поместить папку 
репозитория в директорию проекта и добавить в необходимое место в своей программу строчку 

    #include "key-value-storage/key-value-storage.h"
Чтобы понять, за сколько отработало тестовое приложение, можно воспользоваться следующей командой:

    make main && time ./main
### Системные требования

Библиотека предназначена для работы под Linux. 

Место на диске: рекомендуется иметь на 
диске достаточное количество места для хранения всех необходимых значений 
(память на чистые значения + 5 байт * число значений + 1Кб).

Оперативная память: рекомендуется иметь 2048 * размер ключа * \log_{256} n свободных байт памяти. 

Для запуска тестов необходимо иметь установленную библиотеку [Google Test](https://github.com/google/googletest)

### Предостережение
1. В текущей реализации при обращении к несуществующим в хранилище
ключам при помощи команд get или del программа гарантированно выкинет std::runtime_error.

2. Не рекомендуется содавать несколько хранилищ с одинаковыми именами. Это может привести к undefined behaviour

3. Тестирование может занять некоторое время. Так, предложенный комплкет тестов, в среднем отрабатывает за 17 секунд
без использования дополнительных утилит. С использованием, к примеру, утилиты _valgrind_ время работы может достигать 400 секунд.  
Нормальное время работы тестового приложения - 1 минута.

4. Поскольку в программе предствлена простейшая сериализация с приведением ключа к бинарному виду как он есть, 
попытка хранения, структур обладающих указателями на динамически выделенную память может привести к undefined_behaviour
